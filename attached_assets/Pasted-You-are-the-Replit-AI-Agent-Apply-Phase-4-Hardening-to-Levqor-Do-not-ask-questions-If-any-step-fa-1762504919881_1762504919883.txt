You are the Replit AI Agent. Apply Phase-4 Hardening to Levqor. Do not ask questions. If any step fails, STOP and print: FAIL <step> <file> <reason>. Never print secrets or PII.

GOALS (fix the audit gaps)
1) Turn on async queue (Redis) + DLQ + idempotency
2) Add security headers (CSP, HSTS, etc.)
3) Add rate limits (per API key and per IP)
4) Verify webhook signatures for all inbound providers
5) Backups + restore drill + RTO/RPO proofs
6) Observability: Sentry + traces + richer /metrics
7) Abuse controls: free-plan bind + referral anti-fraud
8) Run verification suite and write rollback plan

ENV (must exist; never echo)
REDIS_URL=...
POSTGRES_URL=...
SENTRY_DSN_BE=...
ALLOWED_ORIGINS=["https://<vercel>", "https://<domain>"]
PROVIDERS: SLACK_WEBHOOK_URL, NOTION_API_KEY, GOOGLE_SERVICE_ACCOUNT_JSON, GOOGLE_SHEETS_SPREADSHEET_ID, TELEGRAM_BOT_TOKEN
STRIPE_WEBHOOK_SECRET (already live)

FEATURE FLAGS
- NEW_QUEUE_ENABLED=true
- SECURITY_HEADERS_ENABLED=true
- RATELIMIT_ENABLED=true
- WEBHOOK_VERIFY_ALL=true
- ABUSE_GUARDS_ENABLED=true

CHANGES

A) QUEUE + DLQ + IDEMPOTENCY
- Add `queue/worker.py` (RQ) with retry(backoff), DLQ push on max attempts.
- Add `queue/tasks.py` with `@idempotent(key)` guard storing keys in Redis set with TTL.
- Update actions to `enqueue()` if NEW_QUEUE_ENABLED else run sync.
- New endpoints:
  - GET `/ops/queue_health` → {depth, retry, dlq}
  - POST `/ops/dlq/retry` → retries N items (admin only)

B) SECURITY HEADERS (Flask middleware)
- If SECURITY_HEADERS_ENABLED:
  - `Content-Security-Policy: default-src 'self'; img-src * blob: data:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://plausible.io; style-src 'self' 'unsafe-inline'; connect-src 'self' https:`
  - `Strict-Transport-Security: max-age=15552000; includeSubDomains`
  - `X-Frame-Options: DENY`
  - `Referrer-Policy: strict-origin-when-cross-origin`
  - `Permissions-Policy: camera=(), microphone=(), geolocation=()`

C) RATE LIMITS
- Implement `ratelimit.py` using Redis tokens:
  - Free: 60 rpm per API key AND 30 rpm per IP
  - Pro: 600 rpm per API key AND 120 rpm per IP
  - On breach → 429 JSON `{error:"rate_limited", retry_after:<sec>}`
- Enforce on all `/actions/*`, `/billing/*`, `/api/*` POST endpoints.
- Expose counters in `/metrics`: `rate_limit_hits_total{scope="ip|key"}`

D) WEBHOOK SIGNATURES
- General verifier module `webhooks/verify.py`:
  - Stripe: existing
  - Slack: `X-Slack-Signature` + timestamp
  - Telegram/Notion inbound: reject unless signature/secret present
- Gate by `WEBHOOK_VERIFY_ALL`; unknown or missing signature → 401.

E) BACKUPS & RESTORE DRILL
- `db/backup.py`: daily dump to `/backups/pg/` with timestamp; keep 7 days.
- `db/restore_verify.py`: restore latest to temp DB, run parity counts (users, orgs, workflows, jobs), target ≤ 30 min.
- Add cron line in project scheduler (not system crontab): run daily 03:00 UTC via APScheduler job.

F) OBSERVABILITY
- Initialize Sentry (SENTRY_DSN_BE).
- `/metrics` additions:
  - `api_latency_p95_ms`
  - `queue_depth`
  - `dlq_depth`
  - `connector_5xx_total{provider}`
  - `error_rate_total`
  - `ai_cost_daily_usd`
- Add trace IDs in logs; correlate worker → API.

G) ABUSE CONTROLS
- Free plan bind: require verified email; store `first_device_hash` on first run; if new device+ASN changes > threshold in 24h → 402 with upgrade hint.
- Referral anti-fraud: block credits if (>5 signups/day from same ASN or distance < 100m with different emails); log `referral_block_total`.

H) TESTS + DOCS
- `tests/test_security_headers.py` → assert headers present when flag on.
- `tests/test_ratelimit.py` → exceed → 429.
- `tests/test_queue_dlq.py` → poison task ends in DLQ.
- `docs/OPERATIONS.md` → on-call runbook, rollback steps, incident comms.
- `docs/SECURITY_HARDENING.md` → headers, webhook verification, rotation policy.

VERIFICATION (must pass)
1) `/status` → pass
2) `/ops/queue_health` → returns depth fields; when NEW_QUEUE_ENABLED=false shows `"mode":"sync"`
3) `/metrics` contains the new counters
4) Security headers present in response
5) Rate limit test returns 429 after threshold
6) Webhook negative test: missing signature → 401
7) Backup + restore parity: prints `PARITY:100%` (counts match)
8) DLQ smoke: inject failing job → appears in DLQ → retried successfully

OUTPUT SUMMARY (non-sensitive)
- queue_mode: sync|async
- queue_health: depth, retry, dlq
- headers_enabled: true|false
- ratelimit_enabled: true|false
- webhook_verify_all: true|false
- backup_last_run: ISO8601
- restore_parity: %
- metrics_sample: 5 lines
- next_steps: any failed checks with file paths

SAFETY & ROLLBACK
- On any FAIL: set flags `NEW_QUEUE_ENABLED=false`, `RATELIMIT_ENABLED=false`, `WEBHOOK_VERIFY_ALL=false`, `SECURITY_HEADERS_ENABLED=false`; print failing file and git diff path; DO NOT DEPLOY.